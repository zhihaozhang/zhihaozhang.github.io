<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Chih-Hao&#39;s Blog" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        浅谈函数式编程 (Introducing Functional Programming)｜undefined
        
    </title>

    <link rel="canonical" href="http://zhihaozhang.github.io/2018/07/30/FunctionalPrograming/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Chih-Hao&#39;s Blog
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>浅谈函数式编程 (Introducing Functional Programming)</h1>
                    
                    <span class="meta">
                         作者 Chih-Hao
                        <span>
                          日期 2018-07-30
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#swift"
                           title="swift">swift</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            浅谈函数式编程 (Introducing Functional Programming)
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近两周利用空余时间<strong>艰难</strong>“啃完”了objc.io出版的<a href="https://objccn.io/products/functional-swift/" target="_blank" rel="external">《函数式Swift》</a>这本书，感觉有些摸到了函数式编程的门道;在函数式编程<strong>思维</strong>的影响下，将之前的项目代码进行了改造。关于函数式编程，也算是有了一点心得，遂写成此文，虽然行文主要是以Swift为<strong>载体</strong>，但并不影响函数式思想的介绍。由于本人才疏学浅，而函数式编程本身<em>博大精深</em>，故谬误在所难免，如发现，还请指出。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fts0h9ibzrj31kw0r2ahf.jpg" alt=""></p>
<blockquote>
<p>《函数式Swift》</p>
</blockquote>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="WHAT-is-函数式编程"><a href="#WHAT-is-函数式编程" class="headerlink" title="WHAT is 函数式编程"></a>WHAT is 函数式编程</h2><p>wiki对于函数式编程的定义如下:</p>
<blockquote>
<p>In computer science, functional programming is a <strong>programming paradigm</strong>—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. It is a <strong>declarative</strong> programming paradigm, which means programming is done with expressions or declarations instead of statements. </p>
</blockquote>
<p>我认为最重要的两个单词是<strong>programming Paradigm</strong>和<strong>declarative</strong>，而后者又是为了描述前者准备的。什么是programming Paradigm？我在前几个月写的博客<a href="http://zhihaozhang.github.io/2018/05/20/ProtocolOP/">《面向协议编程初探》</a>中已经解释过了，中文可以翻译为<em>编程范式</em>，我理解为<strong>编程语言设计者希望编程语言的使用者在使用编程语言的时候，思考问题的方式。</strong></p>
<p>而declarative可以翻译为<em>声明式</em>的，与之相对应的是<strong>imperative</strong>(指令式的)，目前最为广泛使用的<em>面向对象编程</em>就可以划到指令式编程这一类。(declarative和imperative的区别在下文中有所提及)</p>
<h2 id="函数式编程的和面向对象编程的历史"><a href="#函数式编程的和面向对象编程的历史" class="headerlink" title="函数式编程的和面向对象编程的历史"></a>函数式编程的和面向对象编程的历史</h2><p>在函数式编程面前，面向对象编程其实是晚辈。如果以smalltalk的出现作为面向对象编程元年，那么面向对象编程的历史应该从1975年算起(数据来源<a href="https://baike.baidu.com/item/smalltalk/1379989?fr=aladdin" target="_blank" rel="external">百度百科</a>);而函数式编程的元年可以追溯到Lisp语言出现的1958年(数据来源<a href="https://baike.baidu.com/item/LISP/22083" target="_blank" rel="external">百度百科</a>)。</p>
<p>函数式编程被很多大佬美誉为<strong>the next big thing</strong>，甚至被称为<strong>最好</strong>的编程范式。让人不免疑惑，既然比面向对象编程出来的早，为什么之前没火，而现在又火了呢？</p>
<h2 id="WHY函数式编程这两年又火了"><a href="#WHY函数式编程这两年又火了" class="headerlink" title="WHY函数式编程这两年又火了"></a>WHY函数式编程这两年又火了</h2><p>带着疑问，我在搜索引擎中搜索了“函数式编程”和“火了”这两个关键词，找到了一个<a href="https://www.zhihu.com/question/30190384/answer/142902047" target="_blank" rel="external">知乎问答</a>，了解了这一段历史。</p>
<p>很赞成知乎用户<em>狗好看</em>的回答:</p>
<blockquote>
<p>根本的原因是<em>摩尔定律</em>不适用。cpu的性能提升将体现在<strong>核数</strong>增加，这样并行的程序运行速度会越来越快。并行的程序的写法就是找出不能并行的地方，其他地方都尽量并行。如果要这样写，最需要避免的事情就是赋值。函数式编程的本质就是，规避掉“赋值”。</p>
</blockquote>
<p>他的回答比较不容易懂，我来用我的理解<em>翻译翻译</em>。</p>
<blockquote>
<p>摩尔定律: 当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。</p>
</blockquote>
<p>越来越多的人知道，放在初期还是成立的摩尔定律，最近有点不适用了。这和其他很多学科一样，开始的指数级发展，很容易让人过于乐观，到了瓶颈期后，学科发展很容易停滞不前。一个最明显的例子是医学领域关于癌症的笑话，说癌症被攻克，<strong>永远还需要30年</strong>。我用的第一台电脑的CPU是<strong>奔腾4</strong>的，同期经常听到的词还有<strong>赛扬</strong>处理器，奔四有1.4GHz左右的内核时钟，到今天我用的是2016年的顶配MacBook Pro，查了一下，参数为2.7GHz(<em>约20年过去了，还不到2000年的两倍</em>)。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fts1rk3ge3j30wk0jo46i.jpg" alt=""></p>
<blockquote>
<p>2016年的顶配MacBook Pro</p>
</blockquote>
<p>Intel的工程师也尝试过将这一参数加到3GHz甚至更高，但是他们发现功耗太高、发热太快。但是每年产品线又要更新，那怎么办呢？只能是往CPU里<em>塞核心</em>来获得<strong>计算能力</strong>和<strong>吞吐量</strong>，刚刚发布的MacBook Pro 2018顶配已经用上了<strong>多达6核心的i9</strong>处理器，甚至连iPhone X都已经有了6个核心。将这些核心都利用上，可以让设备充分发挥作用，如果没有充分利用，很多核心就会在那里空转。为了充分利用多核心，在面向对象编程的世界中，经常用到的技术是<strong>同步机制和加锁</strong>，但由于函数式编程的特性，在函数式编程的世界里就不会出现这个问题，因此函数式编程又<strong>火了</strong>。</p>
<p>其实在科技界这种死灰复燃的例子还有很多，zelear的<em>王自如</em>在他的节目《科技相对论》<a href="http://www.zealer.com/post/223.html" target="_blank" rel="external">小众产品复活指南</a>里曾经介绍过几款死灰复燃产品，比如：<em>有轨电车、死飞、机械键盘、拍立得、车载广播</em>等。这些产品和函数式编程一样，都没有被<strong>替代</strong>的那么彻底，时过境迁，找到了合适的土壤，用户突然又开始想念他的某个功能，所以又活过来了。</p>
<h1 id="函数式编程的特性-HOW"><a href="#函数式编程的特性-HOW" class="headerlink" title="函数式编程的特性(HOW)"></a>函数式编程的特性(HOW)</h1><p>很遗憾，经过上一节的解释，我依然未能说清函数式编程是什么。这个问题跟面向对象等其他编程范式一样很难给出准确的定义，只能从几个比较<strong>热门</strong>的特性列举一些例子。</p>
<h2 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h2><p>函数的重要性在函数式编程里不言而喻，在支持函数式编程特性的语言里，函数被<strong>提到</strong>了一个非常重要的位置，他跟<em>Int、String、Bool</em>有着相同的地位。函数可以作为变量的字面量存储起来、作为函数的参数和返回值在函数之间传递。</p>
<p>函数作为变量的例子很多，只想说一句话：</p>
<blockquote>
<p>闭包是函数的<em>字面量</em>，就像1之于Int，true之于Bool。</p>
</blockquote>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>接下来举一个函数作为返回值的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addFactory</span><span class="params">(value1 : Int)</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)&#123;</div><div class="line">		<span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">(value2 : Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">				<span class="keyword">return</span> value1+value2</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> adder</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> addOne = addFactory(<span class="number">1</span>)</div><div class="line">addOne(<span class="number">2</span>)  <span class="comment">// return 3</span></div><div class="line"></div><div class="line">addFactory(<span class="number">1</span>)(<span class="number">2</span>)  <span class="comment">// return 3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(value1 : Int , value2 : Int)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> value1 + value2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addFactory返回的值是一个函数，其类型为(Int -&gt; Int),意思是返回值是一个接受Int并且返回Int的函数，我们可以用两种方式调用它。其中第二种addFactory(1)(2)又被称为我们习以为常的add(1,2)这种函数调用方式的<strong>Currying(柯里化)</strong>。多说一句，Currying是一个人的名字，他的全名叫<em>Haskell</em> Currying，剩下的应该不需要多解释了。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受其它函数作为参数的函数有时被称为<strong>高阶函数</strong>。或许大多数人都使用过<em>Map/Reduce/Filter</em>，他们就是高阶函数最常见的例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</div><div class="line"></div><div class="line"><span class="comment">// way 1</span></div><div class="line"><span class="keyword">let</span> strs : [<span class="type">String</span>] = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">0</span>..&lt;nums.<span class="built_in">count</span>) &#123;</div><div class="line">	strs[i] = <span class="string">"No."</span> + <span class="type">String</span>(nums[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// way 2</span></div><div class="line"><span class="keyword">let</span> brr = nums.<span class="built_in">map</span> &#123;</div><div class="line">    <span class="string">"No."</span> + <span class="type">String</span>($<span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以Map为例，假设我们有这样一个需求，将一个整型数组，变为一个String类型的数组，并且在每个数字前加上“No.”，一个没有函数式编程思想的程序员极可能写出way1的代码，这种循环的代码几乎每个程序员都写了几千遍了，很好懂也并没有觉得有什么异常，但其实这是一种<strong>指令式</strong>的编程方式。何为指令式编程呢？就是人以机器的思维方式去思考，我们把自己当做了一台机器，比如上面way1的实现方式，就是我们将思维映射到了CPU上，强迫自己像CPU一样去思考。机器是怎么处理这个问题的呢？他首先要开辟一片内存，然后变更寄存器的值映射到变量i上，通过递增来做循环，然后创建字符串的字面量放到刚开辟出来的内存指定位置上。</p>
<p>way2使用了集合类型的高阶函数，它接收一个参数，这个参数是另一个函数(函数名不重要)，负责String的初始化的方法。当它拿到这个函数之后，自动帮我们把里面的每一个元素拿出来，传到这个String的初始化函数里面去，就生成了最终的数组。这就是<strong>声明式编程</strong>，好处很明显，代码比以前短了很多，思维方式变得更像人思考的方式了。</p>
<p>有了高阶函数，函数可以自由<strong>装配</strong>，由一些简单的函数<strong>装配</strong>出一些高级的函数。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fts5pfl6e9j30fz089jrz.jpg" alt=""></p>
<blockquote>
<p>装配过程的可视化</p>
</blockquote>
<p>关于函数组合的例子，《函数式Swift》给出的实例是对CoreImage库的使用，对一幅图像进行<strong>模糊、加滤镜、切圆角</strong>等操作。一些网红照片的出炉，通常也是由这些看似最简单的操作组合起来的。</p>
<h2 id="纯函数-pure-function"><a href="#纯函数-pure-function" class="headerlink" title="纯函数(pure function)"></a>纯函数(pure function)</h2><p>在函数式编程中，对于函数还有两点特殊的要求。</p>
<ol>
<li>不依赖外部</li>
<li>不改变外部<br>满足上面两点要求的函数被称为<em>纯函数(pure function)</em>。这两点保证了无论在什么时候调用函数，对于相同的输入，总会得到相同的输出。这至少带来了两点好处：</li>
</ol>
<p>1.函数的可测试性</p>
<p>2.上文提到的函数式编程没有的<em>同步与加锁</em>问题</p>
<p>至此也可以引出函数式编程的<strong>思想</strong>了:</p>
<blockquote>
<p>避免使用程序状态和可变对象，是降低程序复杂度的有效方式之一，而这也正是函数式编程的精髓。函数式编程强调执行的结果，而非执行的过程。我们先构建一系列简单却具有一定功能的小函数，然后再将这些函数进行组装以实现完整的逻辑和复杂的运算，这是函数式编程的基本思想。</p>
</blockquote>
<h2 id="函子、适用函子、单子-Functor-Applicative-Monad"><a href="#函子、适用函子、单子-Functor-Applicative-Monad" class="headerlink" title="函子、适用函子、单子(Functor, Applicative, Monad)"></a>函子、适用函子、单子(Functor, Applicative, Monad)</h2><p>这个部分需要单独写一篇文章介绍，我在理解过程中发现了一个很好的<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">图解blog</a>.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fts5vo3dsoj30og07gmy7.jpg" alt=""></p>
<p>这里先给出结论：<br>functor: 通过 fmap 或者 &lt;$&gt; 应用是函数到封装过的值<br>applicative: 通过 &lt;*&gt; 或者 liftA 应用封装过的函数到封装过的值<br>monads: 通过 &gt;&gt;= 或者 liftM 应用会返回封装过的值的函数到封装过的值</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《函数式Swift》(<a href="https://objccn.io/products/functional-swift/" target="_blank" rel="external">https://objccn.io/products/functional-swift/</a>)</li>
<li>smallTalk 百度百科 (<a href="https://baike.baidu.com/item/smalltalk/1379989?fr=aladdin" target="_blank" rel="external">https://baike.baidu.com/item/smalltalk/1379989?fr=aladdin</a>)</li>
<li>Lisp 百度百科(<a href="https://baike.baidu.com/item/LISP/22083" target="_blank" rel="external">https://baike.baidu.com/item/LISP/22083</a>)</li>
<li>知乎:为什么函数式编程这两年又火了(<a href="https://www.zhihu.com/question/30190384/answer/142902047" target="_blank" rel="external">https://www.zhihu.com/question/30190384/answer/142902047</a>)</li>
<li>《科技相对论》小众产品复活指南(<a href="http://www.zealer.com/post/223.html" target="_blank" rel="external">http://www.zealer.com/post/223.html</a>)</li>
<li>Functor, Applicative, 以及 Monad 的图片阐释 (<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">http://jiyinyiyong.github.io/monads-in-pictures/</a>)</li>
</ol>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/08/02/Match3/" data-toggle="tooltip" data-placement="top"
                           title="Match for iPhone开发笔记 <三> 测试与上架篇">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/07/23/Match2/" data-toggle="tooltip" data-placement="top"
                           title="Match for iPhone开发笔记 <二> 网络请求和数据流篇">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WHAT-is-函数式编程"><span class="toc-text">WHAT is 函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程的和面向对象编程的历史"><span class="toc-text">函数式编程的和面向对象编程的历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WHY函数式编程这两年又火了"><span class="toc-text">WHY函数式编程这两年又火了</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数式编程的特性-HOW"><span class="toc-text">函数式编程的特性(HOW)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一等函数"><span class="toc-text">一等函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Currying"><span class="toc-text">Currying</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纯函数-pure-function"><span class="toc-text">纯函数(pure function)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函子、适用函子、单子-Functor-Applicative-Monad"><span class="toc-text">函子、适用函子、单子(Functor, Applicative, Monad)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Chih-Hao&#39;s Blog 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://zhihaozhang.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
